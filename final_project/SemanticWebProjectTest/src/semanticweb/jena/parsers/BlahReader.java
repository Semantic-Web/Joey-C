package semanticweb.jena.parsers;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.util.HashMap;

import org.apache.jena.atlas.web.ContentType;
import org.apache.jena.riot.ReaderRIOT;
import org.apache.jena.riot.system.ErrorHandler;
import org.apache.jena.riot.system.ErrorHandlerFactory;
import org.apache.jena.riot.system.ParserProfile;
import org.apache.jena.riot.system.StreamRDF;

import semanticweb.jena.JenaLangAdapter;

import com.hp.hpl.jena.graph.Triple;
import com.hp.hpl.jena.ontology.Individual;
import com.hp.hpl.jena.ontology.OntClass;
import com.hp.hpl.jena.ontology.OntModel;
import com.hp.hpl.jena.rdf.model.ModelFactory;
import com.hp.hpl.jena.rdf.model.Property;
import com.hp.hpl.jena.rdf.model.RDFNode;
import com.hp.hpl.jena.rdf.model.Resource;
import com.hp.hpl.jena.rdf.model.ResourceFactory;
import com.hp.hpl.jena.sparql.util.Context;
import com.hp.hpl.jena.vocabulary.RDF;

/**
 * ReaderRIOT component that parses the BLAH language and produces OWL objects.
 * This parser is intentionally simplistic and only meant as proof of concept to
 * to transform data into RDF triples to interoperate with DCATModel query engine.
 * 
 * The BLAH language is given as the following syntax.  
 * 
 * (Resource) (Property)            (RDFNode)
 * #subject   predicateRelationship #object
 * 
 * Each line expresses a subject, predicate, object relationship, where individuals are represented
 * as objects with no spaces who start with a hash (#) character.  Every resource is considered to
 * be the type BlahPerson and as such the language has no property of specifying type.  
 * 
 * The relationship between one another is the predicateRelationship which stands for a property in blah_ontology.
 * The predicateRelationship of a Resource can either be to a Resource or Literal, no processing on Literals
 * is done.
 * 
 * Minor validation against the ontology is performed against the class generated by schemagen, 
 * e.g. checking that the property exists in ontology.  
 * Any properties that aren't are considered malformed and shall be ignored. 
 * 
 * @author Joey Carson <jcarson8@fau.edu>
 *
 */
public class BlahReader implements ReaderRIOT {

	// Provides ease of installation using JenaUtil.installLanguage().
	// Ideally all readers would do this.
	public static final String LangName = "BLAH";
	public static final String LangContentType = "text/blah";
	public static final String[] FileExtensions = {"blah"};
	public static final JenaLangAdapter LangAdapter = JenaLangAdapter.create(LangName, ContentType.create(LangContentType), new BlahReaderFactory(), RDFBlahReader.class, FileExtensions);
	
	private ErrorHandler errorHandler = ErrorHandlerFactory.getDefaultErrorHandler();
	
	/**
	 * Maps all known individual objects.
	 */
	private HashMap<Resource, OntClass> individualManifest = new HashMap<Resource, OntClass>();
	
	// m is an OntModel only used for debugging the parser.
	// All triples should be added to the model just as they would be added to the 
	// StreamRDF output as the OntModel provides a clear RDF/XML serialization of the objects.
	private OntModel m = ModelFactory.createOntologyModel();
	
	@Override
	public ErrorHandler getErrorHandler() {
		return errorHandler;
	}


	@Override
	public void read(InputStream in, String baseURI, ContentType ct, StreamRDF output, Context context) {
		InputStreamReader isr = new InputStreamReader(in);
		read(isr, baseURI, ct, output, context);
	}

	@Override
	public void read(Reader in, String baseURI, ContentType ct, StreamRDF output, Context context) {
		individualManifest.clear();
		m.removeAll();
		m.setNsPrefix("blah", BlahPerson.getURI());
		BufferedReader buff = new BufferedReader(in);
		
		try {
			// Read line by line.
			String line = null;
			while (  ( line = buff.readLine() ) != null ) {
				
				line = line.trim();
				
				if ( line.length() > 0 && line.startsWith("#")) { 
					// Extract subject, predicate, and object triple.
					
					int firstSpaceIndex = line.indexOf(" ");
					String subject = line.substring(0, firstSpaceIndex).trim();
					
					int secondSpaceIndex = line.indexOf(" ", firstSpaceIndex + 1);
					String predicate = line.substring(firstSpaceIndex + 1, secondSpaceIndex).trim();
					
					String object = line.substring(secondSpaceIndex + 1).trim();
					
					if ( !subject.isEmpty() && !predicate.isEmpty() && !object.isEmpty() ) {
						Triple t = createTriple(subject, predicate, object);
						
						if ( t != null ) {
							output.triple(t);
						} else {
							System.err.printf("Statement is malformed.  Ignoring subj: " + subject + " pred: " + predicate + " object: " + object);
						}
					}
				}
			}
			
		} catch (IOException e) {
			System.out.println("BlahReader::read failed reading input stream.");
			e.printStackTrace();
		}
		
		// For each individual that was discovered during the parsing process, assert
		// that individuals rdf:type into the output RDF as well.
		for (Resource uri : individualManifest.keySet()) {
			m.add(uri, RDF.type, individualManifest.get(uri));
			Triple t = new Triple(uri.asNode(), RDF.type.asNode(), individualManifest.get(uri).asNode());
			output.triple(t);
		}
		
		System.out.println("BlahReader::read.  RDF/XML representation of input file.");
		//m.write(System.out);
		System.out.println(output);
	}
	
	/**
	 * Creates a triple based on the parsed input strings.
	 * @param subjIn - The subject, assumed begin with a #.
	 * @param predIn
	 * @param objIn
	 * @return
	 */
	private Triple createTriple(String subjIn, String predIn, String objIn) 
	{	
		Triple triple = null;
		// #subject predicate [#]object
		// The subject is effectively the object ID.
		String subj = BlahPerson.getURI() + subjIn.substring(1);
		Individual i = BlahPerson.BlahPerson.createIndividual(subj);
		if ( !individualManifest.containsKey(subj) ) {
			individualManifest.put(i, BlahPerson.BlahPerson);
		}
		
		// See if the predicate is supported.
		String pred = BlahPerson.getURI() + predIn;
		Property predicate = null;
		
		if ( pred.compareTo(BlahPerson.hasFirstName.toString()) == 0 ) {
			predicate = BlahPerson.hasFirstName;
		} else if ( pred.compareTo(BlahPerson.hasLastName.toString()) == 0 ) {
			predicate = BlahPerson.hasLastName;
		} else if ( pred.compareTo(BlahPerson.hasFavoriteFood.toString()) == 0 ) {
			predicate = BlahPerson.hasFavoriteFood;
		} else if ( pred.compareTo(BlahPerson.worksAt.toString()) == 0 ) {
			predicate = BlahPerson.worksAt;
		} else if ( pred.compareTo(BlahPerson.hasFriend.toString()) == 0 ) {
			predicate = BlahPerson.hasFriend;
		}
		
		RDFNode object = null;
		if ( predicate != null ) {
			// Now construct the object.  The object can be a resource or a literal.
			// In our BLAH format, a resource starts with a # character and is assumed to
			// have no spaces.
			if ( objIn.startsWith("#") ) {
				// We've got a resource.
				String individualURI = BlahPerson.getURI() + objIn.substring(1);
				object = BlahPerson.BlahPerson.createIndividual( individualURI );
			} else {
				// Otherwise we assume it's a literal and take the whole string, spaces and all
				object = ResourceFactory.createTypedLiteral(objIn);
			}
		
			m.add(i, predicate, object);
			triple = new Triple(i.asNode(), predicate.asNode(), object.asNode());
		}
		
		return triple;
	}

	@Override
	public void setErrorHandler(ErrorHandler arg0) {
		errorHandler = arg0;
	}

	@Override
	public void setParserProfile(ParserProfile arg0) {
		System.out.println("BlahReader::setParserProfile: ignoring " + arg0);
	}

	@Override
	public ParserProfile getParserProfile() {
		System.out.println("BlahReader::getParserProfile: returning null");
		return null;
	}

}
